{"ast":null,"code":"// src/utils/validators.ts\n\nconst WHITELIST = [\"echo\", \"date\", \"whoami\", \"uptime\", \"ls\", \"cat\", \"hostname\"];\nconst FORBIDDEN = [\"|\", \"&&\", \";\", \"$(\", \"`\", \">\", \"<\", \"rm \", \"sudo\", \"shutdown\", \"reboot\"];\n\n/**\r\n * Validates a command string based on the backend's whitelist/blacklist.\r\n * @param command The command to validate.\r\n * @returns A promise that rejects with an error message if invalid.\r\n */\nexport const validateCommand = (_, value) => {\n  if (!value || value.trim().length === 0) {\n    return Promise.reject(new Error(\"Command cannot be empty.\"));\n  }\n  const lower = value.toLowerCase();\n  for (const f of FORBIDDEN) {\n    if (lower.includes(f)) {\n      return Promise.reject(new Error(`Command contains forbidden operator: ${f}`));\n    }\n  }\n  let firstToken = value.trim().split(/\\s+/)[0];\n  if (firstToken.includes(\"/\")) {\n    firstToken = firstToken.substring(firstToken.lastIndexOf('/') + 1);\n  }\n  if (!WHITELIST.includes(firstToken)) {\n    return Promise.reject(new Error(`Command '${firstToken}' is not in the whitelist. Allowed: ${WHITELIST.join(', ')}`));\n  }\n  return Promise.resolve();\n};","map":{"version":3,"names":["WHITELIST","FORBIDDEN","validateCommand","_","value","trim","length","Promise","reject","Error","lower","toLowerCase","f","includes","firstToken","split","substring","lastIndexOf","join","resolve"],"sources":["C:/Users/haris/Desktop/Task-1_UI/src/utils/validators.ts"],"sourcesContent":["// src/utils/validators.ts\r\n\r\nconst WHITELIST = [\r\n  \"echo\", \"date\", \"whoami\", \"uptime\", \"ls\", \"cat\", \"hostname\"\r\n];\r\n\r\nconst FORBIDDEN = [\r\n  \"|\", \"&&\", \";\", \"$(\", \"`\", \">\", \"<\", \"rm \", \"sudo\", \"shutdown\", \"reboot\"\r\n];\r\n\r\n/**\r\n * Validates a command string based on the backend's whitelist/blacklist.\r\n * @param command The command to validate.\r\n * @returns A promise that rejects with an error message if invalid.\r\n */\r\nexport const validateCommand = (_: any, value: string) => {\r\n  if (!value || value.trim().length === 0) {\r\n    return Promise.reject(new Error(\"Command cannot be empty.\"));\r\n  }\r\n\r\n  const lower = value.toLowerCase();\r\n\r\n  for (const f of FORBIDDEN) {\r\n    if (lower.includes(f)) {\r\n      return Promise.reject(new Error(`Command contains forbidden operator: ${f}`));\r\n    }\r\n  }\r\n\r\n  let firstToken = value.trim().split(/\\s+/)[0];\r\n  if (firstToken.includes(\"/\")) {\r\n    firstToken = firstToken.substring(firstToken.lastIndexOf('/') + 1);\r\n  }\r\n\r\n  if (!WHITELIST.includes(firstToken)) {\r\n    return Promise.reject(new Error(\r\n      `Command '${firstToken}' is not in the whitelist. Allowed: ${WHITELIST.join(', ')}`\r\n    ));\r\n  }\r\n\r\n  return Promise.resolve();\r\n};"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAG,CAChB,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,CAC5D;AAED,MAAMC,SAAS,GAAG,CAChB,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,QAAQ,CACzE;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAGA,CAACC,CAAM,EAAEC,KAAa,KAAK;EACxD,IAAI,CAACA,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC,EAAE;IACvC,OAAOC,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,0BAA0B,CAAC,CAAC;EAC9D;EAEA,MAAMC,KAAK,GAAGN,KAAK,CAACO,WAAW,CAAC,CAAC;EAEjC,KAAK,MAAMC,CAAC,IAAIX,SAAS,EAAE;IACzB,IAAIS,KAAK,CAACG,QAAQ,CAACD,CAAC,CAAC,EAAE;MACrB,OAAOL,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAAC,wCAAwCG,CAAC,EAAE,CAAC,CAAC;IAC/E;EACF;EAEA,IAAIE,UAAU,GAAGV,KAAK,CAACC,IAAI,CAAC,CAAC,CAACU,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7C,IAAID,UAAU,CAACD,QAAQ,CAAC,GAAG,CAAC,EAAE;IAC5BC,UAAU,GAAGA,UAAU,CAACE,SAAS,CAACF,UAAU,CAACG,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACpE;EAEA,IAAI,CAACjB,SAAS,CAACa,QAAQ,CAACC,UAAU,CAAC,EAAE;IACnC,OAAOP,OAAO,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC7B,YAAYK,UAAU,uCAAuCd,SAAS,CAACkB,IAAI,CAAC,IAAI,CAAC,EACnF,CAAC,CAAC;EACJ;EAEA,OAAOX,OAAO,CAACY,OAAO,CAAC,CAAC;AAC1B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}